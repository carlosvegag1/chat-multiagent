{
  "conversation_id": "20251015T121853_6da610",
  "history": [
    {
      "role": "user",
      "message": "Muestra mis viajes planeados",
      "timestamp": "2025-10-15T12:19:05Z"
    },
    {
      "role": "bot",
      "message": "â€¢ Lis (2025-11-20 â†’ 2025-11-20) â†’ del 20/11/2025 al 20/11/2025 (6 segmentos, creado el 15/10/2025)\nâ€¢ Lisboa â†’ del ? al ? (4 segmentos, creado el 15/10/2025)\nâ€¢ ParÃ­s â†’ del ? al ? (2 segmentos, creado el 15/10/2025)",
      "timestamp": "2025-10-15T12:19:05Z"
    },
    {
      "role": "user",
      "message": "# backend/app/utils/travel_log_manager.py from __future__ import annotations import json, os, re, unicodedata from datetime import datetime, date from typing import Dict, Any, List, Optional, Tuple  ISO_FMT = \"%Y-%m-%dT%H:%M:%S.%fZ\"  # ------------------ NormalizaciÃ³n ciudad â‡„ IATA ------------------  IATA_TO_CITY = {     \"LIS\": \"Lisboa\",     \"MAD\": \"Madrid\",     \"CDG\": \"ParÃ­s\",     \"PAR\": \"ParÃ­s\",     \"BCN\": \"Barcelona\",     \"ROM\": \"Roma\",     \"BER\": \"BerlÃ­n\",     \"OPO\": \"Oporto\",     \"LON\": \"Londres\", }  CITY_ALIASES = {     # --- Lisboa ---     \"lis\": (\"Lisboa\", \"LIS\"),     \"lisb\": (\"Lisboa\", \"LIS\"),     \"lisboa\": (\"Lisboa\", \"LIS\"),     \"lisbon\": (\"Lisboa\", \"LIS\"),     # --- ParÃ­s ---     \"paris\": (\"ParÃ­s\", \"PAR\"),     \"parÃ­s\": (\"ParÃ­s\", \"PAR\"),     \"cdg\": (\"ParÃ­s\", \"CDG\"),     \"par\": (\"ParÃ­s\", \"PAR\"),     # --- Madrid ---     \"madrid\": (\"Madrid\", \"MAD\"),     \"mad\": (\"Madrid\", \"MAD\"),     # --- Barcelona ---     \"barcelona\": (\"Barcelona\", \"BCN\"),     \"bcn\": (\"Barcelona\", \"BCN\"),     # --- Roma ---     \"roma\": (\"Roma\", \"ROM\"),     \"rome\": (\"Roma\", \"ROM\"),     \"rom\": (\"Roma\", \"ROM\"),     # --- BerlÃ­n ---     \"berlin\": (\"BerlÃ­n\", \"BER\"),     \"berlÃ­n\": (\"BerlÃ­n\", \"BER\"),     \"ber\": (\"BerlÃ­n\", \"BER\"),     # --- Oporto ---     \"oporto\": (\"Oporto\", \"OPO\"),     \"porto\": (\"Oporto\", \"OPO\"),     \"opo\": (\"Oporto\", \"OPO\"),     # --- Londres ---     \"londres\": (\"Londres\", \"LON\"),     \"london\": (\"Londres\", \"LON\"),     \"lon\": (\"Londres\", \"LON\"), }   def _strip_accents(s: str) -> str:     return ''.join(c for c in unicodedata.normalize('NFD', s) if unicodedata.category(c) != 'Mn')   def normalize_city(query: Optional[str]) -> Tuple[str, Optional[str]]:     if not query:         return (\"\", None)     q = _strip_accents(query).strip().lower()     q_upper = q.upper()     if q_upper in IATA_TO_CITY:         return (IATA_TO_CITY[q_upper], q_upper)     if q in CITY_ALIASES:         return CITY_ALIASES[q]     q_noacc = _strip_accents(query).lower()     if q_noacc in CITY_ALIASES:         return CITY_ALIASES[q_noacc]     return (query.strip().title(), None)  # ------------------ IO helpers ------------------  def _user_dir(base: str, user: str) -> str:     return os.path.join(base, \"data\", \"v2\", \"users\", user)  def _travel_log_path(base: str, user: str) -> str:     return os.path.join(_user_dir(base, user), \"travel_log.json\")  def _ensure_user_dir(base: str, user: str) -> None:     os.makedirs(_user_dir(base, user), exist_ok=True)  def _now_iso() -> str:     return datetime.utcnow().strftime(ISO_FMT)  def _slugify(text: str) -> str:     text = re.sub(r\"[^a-zA-Z0-9\\-_. ]+\", \"\", text).strip().lower()     text = re.sub(r\"\\s+\", \"-\", text)     return text[:60] if text else \"trip\"  def load_travel_log(base: str, user: str) -> Dict[str, Any]:     path = _travel_log_path(base, user)     if not os.path.exists(path):         _ensure_user_dir(base, user)         base_data = {\"user_id\": user, \"created_at\": datetime.utcnow().isoformat(), \"trips\": []}         with open(path, \"w\", encoding=\"utf-8\") as f:             json.dump(base_data, f, ensure_ascii=False, indent=2)         return base_data     with open(path, \"r\", encoding=\"utf-8\") as f:         return json.load(f)  def save_travel_log(base: str, user: str, data: Dict[str, Any]) -> None:     _ensure_user_dir(base, user)     path = _travel_log_path(base, user)     with open(path, \"w\", encoding=\"utf-8\") as f:         json.dump(data, f, ensure_ascii=False, indent=2)  # ------------------ Fechas ------------------  def _parse_date(s: Optional[str]) -> Optional[date]:     if not s:         return None     try:         return datetime.fromisoformat(s.replace(\"Z\", \"\")).date()     except Exception:         return None  def _segment_dates(seg: Dict[str, Any]) -> Tuple[Optional[date], Optional[date]]:     if \"checkin\" in seg or \"checkout\" in seg:         return _parse_date(seg.get(\"checkin\")), _parse_date(seg.get(\"checkout\"))     if \"date\" in seg:         d = _parse_date(seg.get(\"date\"))         return d, d     return None, None  def _compute_trip_range_from_segments(segments: List[Dict[str, Any]]) -> Tuple[Optional[str], Optional[str]]:     starts, ends = [], []     for s in segments:         d1, d2 = _segment_dates(s)         if d1:             starts.append(d1)         if d2:             ends.append(d2)     if not starts and not ends:         return None, None     start = min(starts) if starts else None     end = max(ends) if ends else start     return (start.isoformat() if start else None, end.isoformat() if end else None)  # ------------------ API de viajes ------------------  def auto_title(dest_or_hint: str, start_date: Optional[str], end_date: Optional[str]) -> str:     if start_date and end_date:         return f\"{dest_or_hint.title()} ({start_date} â†’ {end_date})\"     if start_date:         return f\"{dest_or_hint.title()} ({start_date})\"     return dest_or_hint.title()  def list_trips(base: str, user: str) -> List[Dict[str, Any]]:     return load_travel_log(base, user).get(\"trips\", [])  # ------------------ LIMPIEZA DEFINITIVA ------------------  def clean_travel_log(base: str, user: str, drop_empty: bool = True) -> Dict[str, Any]:     \"\"\"     ğŸ§¹ Limpieza total y robusta del travel_log.json:     - Combina viajes duplicados por ciudad (aunque tengan nombres distintos o fechas vacÃ­as)     - Normaliza nombres e IATA     - Rellena fechas desde segmentos     - Elimina viajes vacÃ­os o incoherentes     \"\"\"     data = load_travel_log(base, user)     trips = data.get(\"trips\", [])     if not trips:         return {\"trips\": [], \"summary\": {\"removed\": 0, \"duplicates\": 0, \"fixed\": 0, \"total\": 0}}      cleaned = []     seen = {}     removed, duplicates, fixed = 0, 0, 0      for t in trips:         segs = t.get(\"segments\", [])         if drop_empty and not segs:             removed += 1             continue          city_h, iata = normalize_city(t.get(\"city\") or t.get(\"title\", \"\"))         t[\"city\"] = city_h         if iata:             t[\"iata\"] = iata          s, e = _compute_trip_range_from_segments(segs)         if s:             t[\"start_date\"] = s         if e:             t[\"end_date\"] = e         if s or e:             fixed += 1          key = city_h.lower().strip()         if key in seen:             seen[key][\"segments\"].extend(t.get(\"segments\", []))             duplicates += 1             continue         seen[key] = t      for city, trip in seen.items():         s, e = _compute_trip_range_from_segments(trip.get(\"segments\", []))         trip[\"start_date\"] = s or trip.get(\"start_date\")         trip[\"end_date\"] = e or trip.get(\"end_date\") or trip[\"start_date\"]         trip[\"title\"] = auto_title(trip[\"city\"], trip[\"start_date\"], trip[\"end_date\"])         trip.setdefault(\"trip_id\", f\"{(trip.get('start_date') or '00000000').replace('-', '')}_{_slugify(trip['city'])}\")         trip.setdefault(\"status\", \"planned\")         trip.setdefault(\"notes\", \"\")         cleaned.append(trip)      data[\"trips\"] = cleaned     save_travel_log(base, user, data)     summary = {\"removed\": removed, \"duplicates\": duplicates, \"fixed\": fixed, \"total\": len(cleaned)}     print(f\"[CleanTravelLog] {user}: removed={removed}, duplicates={duplicates}, fixed={fixed}, total={len(cleaned)}\")     return {         \"status\": \"ok\",         \"message\": f\"Limpieza ejecutada correctamente para {user}.\",         \"summary\": summary     }  # ------------------ CREACIÃ“N / REUSO DE VIAJES ------------------  def create_or_get_trip(base: str, user: str, title_hint: str, start_date: Optional[str], end_date: Optional[str]) -> Dict[str, Any]:     data = load_travel_log(base, user)     trips = data.get(\"trips\", [])     city_h, iata = normalize_city(title_hint)      for t in trips:         c2, _ = normalize_city(t.get(\"city\") or \"\")         if c2.lower() == city_h.lower():             if start_date and not t.get(\"start_date\"):                 t[\"start_date\"] = start_date             if end_date and not t.get(\"end_date\"):                 t[\"end_date\"] = end_date             if iata and not t.get(\"iata\"):                 t[\"iata\"] = iata             save_travel_log(base, user, data)             return t      slug = _slugify(city_h)     trip_id = f\"{(start_date or datetime.utcnow().strftime('%Y-%m-%d')).replace('-', '')}_{slug}\"     trip = {         \"trip_id\": trip_id,         \"created_at\": _now_iso(),         \"title\": auto_title(city_h, start_date, end_date),         \"city\": city_h,         \"iata\": iata,         \"segments\": [],         \"status\": \"planned\",         \"notes\": \"\",         \"agents_called\": [],         \"start_date\": start_date,         \"end_date\": end_date or start_date,     }     data.setdefault(\"trips\", []).append(trip)     save_travel_log(base, user, data)     return trip  # ------------------ AÃ‘ADIR SEGMENTOS ------------------  def add_segment(base: str, user: str, trip_id: str, segment: Dict[str, Any], agent_name: Optional[str] = None) -> Dict[str, Any]:     data = load_travel_log(base, user)     trips = data.get(\"trips\", [])     target = None      for t in trips:         if t.get(\"trip_id\") == trip_id:             target = t             break      if not target:         raise ValueError(f\"Trip not found: {trip_id}\")      target.setdefault(\"segments\", []).append(segment)     if agent_name:         target.setdefault(\"agents_called\", []).append(agent_name)      s, e = _compute_trip_range_from_segments(target[\"segments\"])     if s:         target[\"start_date\"] = s     if e:         target[\"end_date\"] = e      target[\"title\"] = auto_title(target[\"city\"], target.get(\"start_date\"), target.get(\"end_date\"))     save_travel_log(base, user, data)     return target  # ------------------ DETECCIÃ“N DE CONFLICTOS ------------------  def detect_conflicts(base: str, user: str, start_date: Optional[str], end_date: Optional[str], exclude_trip_id: Optional[str] = None):     data = load_travel_log(base, user)     trips = data.get(\"trips\", [])     conflicts = []     s = _parse_date(start_date)     e = _parse_date(end_date)     if not s or not e:         return []     for t in trips:         if exclude_trip_id and t.get(\"trip_id\") == exclude_trip_id:             continue         s2 = _parse_date(t.get(\"start_date\"))         e2 = _parse_date(t.get(\"end_date\"))         if not s2 or not e2:             continue         if not (e < s2 or s > e2):             conflicts.append((t.get(\"trip_id\"), t.get(\"title\")))     return conflicts  # ------------------ RESUMEN PARA CONTEXTO ------------------  def summarize_for_context(base: str, user: str) -> str:     data = load_travel_log(base, user)     trips = data.get(\"trips\", [])     if not trips:         return \"Sin viajes planificados.\"     parts = []     for t in trips:         title = t.get(\"title\") or t.get(\"city\")         start = t.get(\"start_date\")         end = t.get(\"end_date\")         parts.append(f\"{title} ({start} â†’ {end})\")     return \"; \".join(parts)",
      "timestamp": "2025-10-15T12:19:10Z"
    },
    {
      "role": "bot",
      "message": "â€¢ Lis (2025-11-20 â†’ 2025-11-20) â†’ del 20/11/2025 al 20/11/2025 (6 segmentos, creado el 15/10/2025)\nâ€¢ Lisboa â†’ del ? al ? (4 segmentos, creado el 15/10/2025)\nâ€¢ ParÃ­s â†’ del ? al ? (2 segmentos, creado el 15/10/2025)",
      "timestamp": "2025-10-15T12:19:11Z"
    }
  ],
  "created_at": "2025-10-15T12:19:05Z",
  "updated_at": "2025-10-15T12:19:11Z"
}